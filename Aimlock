-- I caught you why are you looking in here

-- DELTA MOBILE PERFECT AIMLOCK - FINAL EDITION
-- Credits: made by the percaholic team | By fkdaf3dz
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UIS = game:GetService("UserInputService")
local Cam = workspace.CurrentCamera
local player = Players.LocalPlayer
local gui = player:WaitForChild("PlayerGui")

-- SETTINGS
local Settings = {
    Prediction = 0.165,
    YOffset = 0.12,
    MaxDistance = 1000,
    Instant = true,
    RefreshRate = 5,
    DriftCorrection = true
}

-- GET TARGET
local function getTarget()
    local closest = nil
    local minDist = 9999
    local center = Vector2.new(Cam.ViewportSize.X / 2, Cam.ViewportSize.Y / 2)
    local camPos = Cam.CFrame.Position
    
    for _, plr in pairs(Players:GetPlayers()) do
        if plr ~= player and plr.Character then
            local humanoid = plr.Character:FindFirstChildOfClass("Humanoid")
            local head = plr.Character:FindFirstChild("Head")
            
            if humanoid and head and humanoid.Health > 0 then
                local dist = (head.Position - camPos).Magnitude
                if dist <= Settings.MaxDistance then
                    local screenPos, onScreen = Cam:WorldToViewportPoint(head.Position)
                    if onScreen then
                        local screenDist = (Vector2.new(screenPos.X, screenPos.Y) - center).Magnitude
                        if screenDist < minDist then
                            minDist = screenDist
                            closest = {
                                Head = head,
                                Humanoid = humanoid,
                                Character = plr.Character,
                                StartTime = tick()
                            }
                        end
                    end
                end
            end
        end
    end
    return closest
end

-- CREATE GUI
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "PerfectAim"
screenGui.ResetOnSpawn = false
screenGui.Parent = gui

-- MAIN BUTTON
local island = Instance.new("Frame")
island.Size = UDim2.new(0, 200, 0, 80)
island.Position = UDim2.new(1, -210, 0, 10)
island.BackgroundColor3 = Color3.new(0, 0, 0)
island.BorderSizePixel = 0
island.Parent = screenGui
Instance.new("UICorner", island).CornerRadius = UDim.new(0, 12)

local text = Instance.new("TextLabel")
text.Size = UDim2.new(1, 0, 1, 0)
text.BackgroundTransparency = 1
text.Text = "PRESETS"
text.Font = Enum.Font.GothamBold
text.TextSize = 36
text.Parent = island

-- LOCK BUTTON
local lockBtn = Instance.new("Frame")
lockBtn.Size = UDim2.new(0, 100, 0, 45)
lockBtn.Position = UDim2.new(0, 10, 0, 85)
lockBtn.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
lockBtn.Parent = screenGui
Instance.new("UICorner", lockBtn).CornerRadius = UDim.new(0, 8)

local lockText = Instance.new("TextLabel")
lockText.Size = UDim2.new(1, 0, 1, 0)
lockText.BackgroundTransparency = 1
lockText.Text = "LOCK"
lockText.Font = Enum.Font.GothamBold
lockText.TextSize = 20
lockText.Parent = lockBtn

-- CREDITS BOX - Bottom Right (Rich Purplish)
local creditsBox = Instance.new("Frame")
creditsBox.Name = "Credits"
creditsBox.Size = UDim2.new(0, 220, 0, 60)
creditsBox.Position = UDim2.new(1, -230, 1, -70)
creditsBox.BackgroundColor3 = Color3.fromRGB(75, 0, 130) -- Rich purple
creditsBox.BackgroundTransparency = 0.3 -- Translucent
creditsBox.BorderSizePixel = 0
creditsBox.Parent = screenGui
Instance.new("UICorner", creditsBox).CornerRadius = UDim.new(0, 8)

-- Purple gradient effect
local gradient = Instance.new("UIGradient")
gradient.Color = ColorSequence.new({
    ColorSequenceKeypoint.new(0, Color3.fromRGB(138, 43, 226)), -- Blue violet
    ColorSequenceKeypoint.new(0.5, Color3.fromRGB(75, 0, 130)), -- Indigo
    ColorSequenceKeypoint.new(1, Color3.fromRGB(48, 25, 52)) -- Dark purple
})
gradient.Rotation = 45
gradient.Parent = creditsBox

local creditsText = Instance.new("TextLabel")
creditsText.Size = UDim2.new(1, 0, 0.5, 0)
creditsText.Position = UDim2.new(0, 0, 0, 5)
creditsText.BackgroundTransparency = 1
creditsText.Text = "made by the percaholic team"
creditsText.Font = Enum.Font.GothamBold
creditsText.TextSize = 14
creditsText.TextColor3 = Color3.fromRGB(255, 255, 255)
creditsText.TextStrokeTransparency = 0.8
creditsText.Parent = creditsBox

local creditsText2 = Instance.new("TextLabel")
creditsText2.Size = UDim2.new(1, 0, 0.5, 0)
creditsText2.Position = UDim2.new(0, 0, 0.5, -2)
creditsText2.BackgroundTransparency = 1
creditsText2.Text = "By fkdaf3dz"
creditsText2.Font = Enum.Font.GothamBold
creditsText2.TextSize = 16
creditsText2.TextColor3 = Color3.fromRGB(255, 215, 0) -- Gold text
creditsText2.TextStrokeTransparency = 0.9
creditsText2.Parent = creditsBox

-- Glow effect
local glow = Instance.new("ImageLabel")
glow.Name = "Glow"
glow.Size = UDim2.new(1.2, 0, 1.2, 0)
glow.Position = UDim2.new(-0.1, 0, -0.1, 0)
glow.BackgroundTransparency = 1
glow.Image = "rbxassetid://5028857084" -- Glow texture
glow.ImageColor3 = Color3.fromRGB(138, 43, 226)
glow.ImageTransparency = 0.7
glow.Parent = creditsBox

-- VANISH AFTER 4-5 SECONDS
spawn(function()
    wait(4.5)
    if creditsBox and creditsBox.Parent then
        creditsBox:Destroy()
    end
end)

-- STATES
local isDragLocked = false
local aimLockActive = false
local currentTarget = nil
local targetDeathConn = nil
local lastHeadPos = nil
local lockStartTime = 0
local frameCount = 0
local lastCorrection = tick()

-- CLEANUP
local function cleanup()
    if targetDeathConn then 
        targetDeathConn:Disconnect() 
        targetDeathConn = nil
    end
    currentTarget = nil
    lastHeadPos = nil
    frameCount = 0
    lastCorrection = tick()
end

local function onDeath()
    cleanup()
    aimLockActive = false
    text.Text = "PRESETS"
    text.TextColor3 = Color3.fromHSV(0, 1, 1)
end

local function setupTarget(targetData)
    cleanup()
    currentTarget = targetData
    lockStartTime = tick()
    lastHeadPos = targetData.Head.Position
    if targetData.Humanoid then
        targetDeathConn = targetData.Humanoid.Died:Connect(function()
            onDeath()
        end)
    end
end

-- DRAGGING
local dragStart, startPos, dragging = nil, nil, false
local dragStart2, startPos2, dragging2 = nil, nil, false

island.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseButton1 then
        dragging = true
        dragStart = input.Position
        startPos = island.Position
    end
end)

island.InputChanged:Connect(function(input)
    if dragging and not isDragLocked and (input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseMovement) then
        local delta = input.Position - dragStart
        if delta.Magnitude > 10 then
            island.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
        end
    end
end)

island.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseButton1 then
        if (input.Position - dragStart).Magnitude <= 10 then
            if aimLockActive then
                aimLockActive = false
                cleanup()
                text.Text = "PRESETS"
            else
                local target = getTarget()
                if target then
                    setupTarget(target)
                    aimLockActive = true
                    text.Text = "LOCKED"
                    text.TextColor3 = Color3.fromRGB(255, 50, 50)
                else
                    text.Text = "NO TARGET"
                    wait(0.3)
                    text.Text = "PRESETS"
                end
            end
        end
        dragging = false
    end
end)

lockBtn.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseButton1 then
        dragging2 = false
        dragStart2 = input.Position
        startPos2 = lockBtn.Position
    end
end)

lockBtn.InputChanged:Connect(function(input)
    if dragStart2 and (input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseMovement) then
        if (input.Position - dragStart2).Magnitude > 10 then
            dragging2 = true
            lockBtn.Position = UDim2.new(startPos2.X.Scale, startPos2.X.Offset + (input.Position.X - dragStart2.X), startPos2.Y.Scale, startPos2.Y.Offset + (input.Position.Y - dragStart2.Y))
        end
    end
end)

lockBtn.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseButton1 then
        if not dragging2 then
            isDragLocked = not isDragLocked
            lockBtn.BackgroundColor3 = isDragLocked and Color3.fromRGB(180, 40, 40) or Color3.fromRGB(40, 40, 40)
            lockText.Text = isDragLocked and "UNLOCK" or "LOCK"
        end
        dragging2 = false
    end
end)

-- MAIN LOOP
local hue, lockHue = 0, 0.5

RunService.RenderStepped:Connect(function(dt)
    frameCount = frameCount + 1
    
    -- RGB
    hue = (hue + dt * 3) % 1
    lockHue = (lockHue + dt * 3) % 1
    if not aimLockActive then text.TextColor3 = Color3.fromHSV(hue, 1, 1) end
    lockText.TextColor3 = Color3.fromHSV(lockHue, 1, 1)
    
    -- Transparency
    island.BackgroundTransparency = 0
    text.TextTransparency = 0
    lockBtn.BackgroundTransparency = 0
    lockText.TextTransparency = 0
    if creditsBox and creditsBox.Parent then
        creditsBox.BackgroundTransparency = 0.3
    end
    
    if aimLockActive and currentTarget then
        -- DRIFT FIX: Reset every 3 seconds
        if tick() - lastCorrection > 3 then
            lastCorrection = tick()
            lastHeadPos = nil
        end
        
        -- Refresh lock periodically
        local timeLocked = tick() - lockStartTime
        if timeLocked > Settings.RefreshRate then
            local refreshed = getTarget()
            if refreshed and refreshed.Character == currentTarget.Character then
                lastHeadPos = currentTarget.Head.Position
                lockStartTime = tick()
                frameCount = 0
                lastCorrection = tick()
            end
        end
        
        -- Validate target
        if not currentTarget.Head or not currentTarget.Head.Parent or currentTarget.Humanoid.Health <= 0 then
            local newTarget = getTarget()
            if newTarget then
                setupTarget(newTarget)
            else
                onDeath()
                return
            end
        end
        
        local head = currentTarget.Head
        
        -- DRIFT FIX
        local currentHeadPos = head.Position
        local velocity = head.Velocity
        
        if not lastHeadPos then
            lastHeadPos = currentHeadPos
        end
        
        local instantVelocity = velocity
        local aimPos = currentHeadPos + Vector3.new(0, Settings.YOffset, 0)
        local predictedPos = aimPos + (instantVelocity * Settings.Prediction)
        
        -- INSTANT LOCK
        local camPos = Cam.CFrame.Position
        Cam.CFrame = CFrame.new(camPos, predictedPos)
        
        lastHeadPos = currentHeadPos
    end
end)

-- BACKUP LOOP
RunService.Heartbeat:Connect(function()
    if aimLockActive and currentTarget and currentTarget.Head then
        local head = currentTarget.Head
        local aimPos = head.Position + Vector3.new(0, Settings.YOffset, 0) + (head.Velocity * Settings.Prediction)
        
        -- DRIFT FIX: Hard recenter if angle is off
        local currentLook = Cam.CFrame.LookVector
        local targetLook = (aimPos - Cam.CFrame.Position).Unit
        local angle = math.acos(math.clamp(currentLook:Dot(targetLook), -1, 1))
        
        if angle > math.rad(2) then
            Cam.CFrame = CFrame.new(Cam.CFrame.Position, aimPos)
        end
    end
end)
